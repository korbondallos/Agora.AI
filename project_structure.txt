================================================================================
СТРУКТУРА ПРОЕКТА
================================================================================
Дата создания: 2025-08-07 18:54:13
Корневая директория: E:\2. Documents\Agora.AI\Project\Agora.AI
================================================================================

ИЕРАРХИЯ ПАПОК И ФАЙЛОВ:
----------------------------------------
├── docs/
│   └── architecture/
│       └── code_map.json
├── src/
│   ├── api/
│   │   └── auth.py
│   ├── infrastructure/
│   │   ├── error/
│   │   │   └── errorHandler.py
│   │   └── monitoring/
│   │       └── monitoringService.py
│   ├── integrations/
│   │   └── telegram/
│   │       └── telegramIntegration.py
│   ├── test/
│   │   ├── test_file.py
│   │   └── test_utilities.py
│   ├── utils/
│   │   ├── .gitkeep
│   │   ├── code_utils.py
│   │   ├── git_integration.py
│   │   ├── interactive_update.py
│   │   ├── project_structure_exporter.py
│   │   └── update_code.py
│   └── main.py
├── .env
├── .gitignore
├── README.md
├── app.py
└── test_env.py

================================================================================

СОДЕРЖИМОЕ ФАЙЛОВ:
----------------------------------------

================================================================================
ФАЙЛ: .env
================================================================================
[БИНАРНЫЙ ФАЙЛ - СОДЕРЖИМОЕ НЕ ПРОЧИТАНО]

================================================================================
ФАЙЛ: .gitignore
================================================================================
[БИНАРНЫЙ ФАЙЛ - СОДЕРЖИМОЕ НЕ ПРОЧИТАНО]

================================================================================
ФАЙЛ: README.md
================================================================================
# Agora.AI
Agora-AI

================================================================================
ФАЙЛ: app.py
================================================================================
# AGORA_BLOCK: start:app
import sys
import os

# Добавляем корневую директорию проекта в sys.path
sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))

# Импортируем приложение из src
from src.main import app

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
# AGORA_BLOCK: end:app

================================================================================
ФАЙЛ: docs\architecture\code_map.json
================================================================================
{
  "metadata": {
    "project": "Agora.AI",
    "version": "1.0.0",
    "last_updated": "2023-11-15T00:00:00Z",
    "description": "Финальная кодовая карта для MVP с масштабируемостью",
    "architecture": "3-layer with event-driven communication",
    "mvp_ready": true,
    "scalable": true,
    "error_handling": "centralized",
    "caching": "transparent",
    "testing": "automated"
  },
  "layers": {
    "ui_layer": {
      "description": "UI Layer (Presentation) - компоненты интерфейса с поддержкой мультиплатформенности",
      "modules": {
        "auth_module": {
          "id": "auth_module",
          "file": "src/ui/auth.module.ts",
          "start_tag": "// AGORA_BLOCK: start:auth_module",
          "end_tag": "// AGORA_BLOCK: end:auth_module",
          "description": "Авторизация через Telegram и в будущем через email/web",
          "dependencies": [
            "api_service",
            "error_handler",
            "telegram_integration"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "auth.success",
            "auth.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "company_profile_module": {
          "id": "company_profile_module",
          "file": "src/ui/companyProfile.module.ts",
          "start_tag": "// AGORA_BLOCK: start:company_profile_module",
          "end_tag": "// AGORA_BLOCK: end:company_profile_module",
          "description": "UI-модуль для редактирования профиля компании",
          "dependencies": [
            "api_service",
            "file_uploader",
            "error_handler",
            "profile_manager"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "profile.updated",
            "profile.created"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "swipe_cards_module": {
          "id": "swipe_cards_module",
          "file": "src/ui/swipeCards.module.ts",
          "start_tag": "// AGORA_BLOCK: start:swipe_cards_module",
          "end_tag": "// AGORA_BLOCK: end:swipe_cards_module",
          "description": "Основная лента свайпов (Tinder-like интерфейс) с анимациями",
          "dependencies": [
            "api_service",
            "match_engine",
            "cache_service",
            "error_handler",
            "card_manager"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "swipe.performed",
            "match.found",
            "match.processed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "logistics_module": {
          "id": "logistics_module",
          "file": "src/ui/logistics.module.ts",
          "start_tag": "// AGORA_BLOCK: start:logistics_module",
          "end_tag": "// AGORA_BLOCK: end:logistics_module",
          "description": "Карта логистики и визуализация маршрутов с интерактивными элементами",
          "dependencies": [
            "api_service",
            "logistics_ai",
            "map_service",
            "error_handler"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "route.optimized",
            "route.selected"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "chat_module": {
          "id": "chat_module",
          "file": "src/ui/chat.module.ts",
          "start_tag": "// AGORA_BLOCK: start:chat_module",
          "end_tag": "// AGORA_BLOCK: end:chat_module",
          "description": "Чат-переговоры между компаниями с поддержкой медиа и документов",
          "dependencies": [
            "api_service",
            "negotiation_orchestrator",
            "realtime_service",
            "error_handler"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "message.sent",
            "message.received",
            "negotiation.updated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "contract_module": {
          "id": "contract_module",
          "file": "src/ui/contract.module.ts",
          "start_tag": "// AGORA_BLOCK: start:contract_module",
          "end_tag": "// AGORA_BLOCK: end:contract_module",
          "description": "Генерация и подписание договоров с электронной подписью",
          "dependencies": [
            "api_service",
            "contract_generator",
            "blockchain_integration",
            "esign_service",
            "error_handler"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "contract.generated",
            "contract.signed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "settings_module": {
          "id": "settings_module",
          "file": "src/ui/settings.module.ts",
          "start_tag": "// AGORA_BLOCK: start:settings_module",
          "end_tag": "// AGORA_BLOCK: end:settings_module",
          "description": "Настройки языка, уведомлений и профиля с темой",
          "dependencies": [
            "api_service",
            "translation_ai",
            "storage_service",
            "error_handler"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "settings.updated",
            "language.changed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "business_logic_layer": {
      "description": "Business Logic Layer - ядро бизнес-логики с event-driven архитектурой",
      "modules": {
        "profile_manager": {
          "id": "profile_manager",
          "file": "src/business/profileManager.py",
          "start_tag": "# AGORA_BLOCK: start:profile_manager",
          "end_tag": "# AGORA_BLOCK: end:profile_manager",
          "description": "Статическая информация о компании, которую заполняет и обновляет пользователь",
          "dependencies": [
            "error_handler",
            "monitoring_service",
            "kyc_verifier"
          ],
          "events": [
            "profile.updated",
            "profile.verified"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "card_manager": {
          "id": "card_manager",
          "file": "src/business/cardManager.py",
          "start_tag": "# AGORA_BLOCK: start:card_manager",
          "end_tag": "# AGORA_BLOCK: end:card_manager",
          "description": "Динамические карточки, создаваемые под конкретный товар/услугу и категорию",
          "dependencies": [
            "profile_manager",
            "product_catalog",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "card.created",
            "card.updated",
            "card.archived"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "product_catalog": {
          "id": "product_catalog",
          "file": "src/business/productCatalog.py",
          "start_tag": "# AGORA_BLOCK: start:product_catalog",
          "end_tag": "# AGORA_BLOCK: end:product_catalog",
          "description": "Каталог товаров компании с категориями и характеристиками",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "product.added",
            "product.updated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "match_engine": {
          "id": "match_engine",
          "file": "src/business/matchEngine.py",
          "start_tag": "# AGORA_BLOCK: start:match_engine",
          "end_tag": "# AGORA_BLOCK: end:match_engine",
          "description": "Ищет подходящие карточки, взаимодействует с AI и фильтрует по категории/роли",
          "dependencies": [
            "card_manager",
            "embedding_service",
            "translation_ai",
            "cache_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "match.found",
            "match.processed",
            "match.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "negotiator_agent_a": {
          "id": "negotiator_agent_a",
          "file": "src/business/ai/negotiatorAgentA.py",
          "start_tag": "# AGORA_BLOCK: start:negotiator_agent_a",
          "end_tag": "# AGORA_BLOCK: end:negotiator_agent_a",
          "description": "AI-переговорщик от компании A (внутренний или внешний)",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "negotiation.message.a"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "negotiator_agent_b": {
          "id": "negotiator_agent_b",
          "file": "src/business/ai/negotiatorAgentB.py",
          "start_tag": "# AGORA_BLOCK: start:negotiator_agent_b",
          "end_tag": "# AGORA_BLOCK: end:negotiator_agent_b",
          "description": "AI-переговорщик от компании B (внутренний или внешний)",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "negotiation.message.b"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "gatekeeper_agent": {
          "id": "gatekeeper_agent",
          "file": "src/business/ai/gatekeeperAgent.py",
          "start_tag": "# AGORA_BLOCK: start:gatekeeper_agent",
          "end_tag": "# AGORA_BLOCK: end:gatekeeper_agent",
          "description": "Агент-Вышибала: проверяет соответствие сообщений правилам",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "gatekeeper.check",
            "gatekeeper.block"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "auditor_agent": {
          "id": "auditor_agent",
          "file": "src/business/ai/auditorAgent.py",
          "start_tag": "# AGORA_BLOCK: start:auditor_agent",
          "end_tag": "# AGORA_BLOCK: end:auditor_agent",
          "description": "Агент-Аудитор: проверяет финальный договор на логические/юридические ошибки",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "audit.completed",
            "audit.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "negotiation_orchestrator": {
          "id": "negotiation_orchestrator",
          "file": "src/business/negotiationOrchestrator.py",
          "start_tag": "# AGORA_BLOCK: start:negotiation_orchestrator",
          "end_tag": "# AGORA_BLOCK: end:negotiation_orchestrator",
          "description": "Оркестратор: управляет сценарием переговоров и вызывает нужных агентов",
          "dependencies": [
            "negotiator_agent_a",
            "negotiator_agent_b",
            "gatekeeper_agent",
            "auditor_agent",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "negotiation.started",
            "negotiation.completed",
            "negotiation.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "contract_generator": {
          "id": "contract_generator",
          "file": "src/business/contractGenerator.py",
          "start_tag": "# AGORA_BLOCK: start:contract_generator",
          "end_tag": "# AGORA_BLOCK: end:contract_generator",
          "description": "Генерация юридических документов с шаблонами и AI",
          "dependencies": [
            "legal_ai",
            "translation_ai",
            "template_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "contract.generated",
            "contract.signed",
            "contract.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "reputation_system": {
          "id": "reputation_system",
          "file": "src/business/reputationSystem.py",
          "start_tag": "# AGORA_BLOCK: start:reputation_system",
          "end_tag": "# AGORA_BLOCK: end:reputation_system",
          "description": "Система репутации и рейтингов компаний с AI-анализом",
          "dependencies": [
            "kyc_verifier",
            "blockchain_integration",
            "cache_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "reputation.updated",
            "reputation.reviewed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "kyc_verifier": {
          "id": "kyc_verifier",
          "file": "src/business/kycVerifier.py",
          "start_tag": "# AGORA_BLOCK: start:kyc_verifier",
          "end_tag": "# AGORA_BLOCK: end:kyc_verifier",
          "description": "Проверка KYC и верификация компаний с интеграцией сервисов",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "kyc.started",
            "kyc.completed",
            "kyc.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "logistics_finder": {
          "id": "logistics_finder",
          "file": "src/business/logisticsFinder.py",
          "start_tag": "# AGORA_BLOCK: start:logistics_finder",
          "end_tag": "# AGORA_BLOCK: end:logistics_finder",
          "description": "Поиск логистических решений и перевозчиков с оптимизацией",
          "dependencies": [
            "logistics_ai",
            "cache_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "logistics.requested",
            "logistics.optimized"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "legal_ai": {
          "id": "legal_ai",
          "file": "src/business/legalAI.py",
          "start_tag": "# AGORA_BLOCK: start:legal_ai",
          "end_tag": "# AGORA_BLOCK: end:legal_ai",
          "description": "AI-юрист для генерации шаблонов договоров по юрисдикциям",
          "dependencies": [
            "translation_ai",
            "template_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "legal.advice.requested",
            "legal.template.generated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "logistics_ai": {
          "id": "logistics_ai",
          "file": "src/business/logisticsAI.py",
          "start_tag": "# AGORA_BLOCK: start:logistics_ai",
          "end_tag": "# AGORA_BLOCK: end:logistics_ai",
          "description": "Анализ логистических маршрутов и узлов с AI-оптимизацией",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "route.analyzed",
            "route.optimized"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "translation_ai": {
          "id": "translation_ai",
          "file": "src/business/translationAI.py",
          "start_tag": "# AGORA_BLOCK: start:translation_ai",
          "end_tag": "# AGORA_BLOCK: end:translation_ai",
          "description": "Адаптация текстов под языки и бизнес-культуру с контекстом",
          "dependencies": [
            "cache_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "translation.requested",
            "translation.completed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "risk_assessor_ai": {
          "id": "risk_assessor_ai",
          "file": "src/business/riskAssessorAI.py",
          "start_tag": "# AGORA_BLOCK: start:risk_assessor_ai",
          "end_tag": "# AGORA_BLOCK: end:risk_assessor_ai",
          "description": "Проверка страновых и контрагентных рисков с AI-анализом",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "risk.assessed",
            "risk.alert"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "test_block": {
          "id": "test_block",
          "file": "src/test/test_file.py",
          "start_tag": "# AGORA_BLOCK: start:test_block",
          "end_tag": "# AGORA_BLOCK: end:test_block",
          "description": "Тестовый блок для проверки утилит",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.2",
          "last_modified": "2025-08-07T18:15:03.893057"
        },
        "embedding_service": {
          "id": "embedding_service",
          "file": "src/business/embeddingService.py",
          "start_tag": "# AGORA_BLOCK: start:embedding_service",
          "end_tag": "# AGORA_BLOCK: end:embedding_service",
          "description": "Сервис для работы с embedding-векторами и семантическим поиском",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "embedding.generated",
            "embedding.searched"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "api_layer": {
      "description": "API Layer (Gateway) - точки входа для фронтенда с валидацией",
      "modules": {
        "auth_login": {
          "id": "auth_login",
          "file": "src/api/auth.py",
          "start_tag": "# AGORA_BLOCK: start:auth_login",
          "end_tag": "# AGORA_BLOCK: end:auth_login",
          "description": "Эндпоинт /auth/login с валидацией и безопасностью",
          "dependencies": [
            "auth_module",
            "telegram_integration",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": false,
          "rate_limit": "5/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "profile_create": {
          "id": "profile_create",
          "file": "src/api/profile.py",
          "start_tag": "# AGORA_BLOCK: start:profile_create",
          "end_tag": "# AGORA_BLOCK: end:profile_create",
          "description": "Эндпоинт /profile/create с валидацией данных",
          "dependencies": [
            "company_profile_module",
            "profile_manager",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "10/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "match_swipe": {
          "id": "match_swipe",
          "file": "src/api/match.py",
          "start_tag": "# AGORA_BLOCK: start:match_swipe",
          "end_tag": "# AGORA_BLOCK: end:match_swipe",
          "description": "Эндпоинт /match/swipe с обработкой в реальном времени",
          "dependencies": [
            "swipe_cards_module",
            "match_engine",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "30/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "logistics_map": {
          "id": "logistics_map",
          "file": "src/api/logistics.py",
          "start_tag": "# AGORA_BLOCK: start:logistics_map",
          "end_tag": "# AGORA_BLOCK: end:logistics_map",
          "description": "Эндпоинт /logistics/map с геоданными",
          "dependencies": [
            "logistics_module",
            "logistics_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "GET",
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "20/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "contract_generate": {
          "id": "contract_generate",
          "file": "src/api/contract.py",
          "start_tag": "# AGORA_BLOCK: start:contract_generate",
          "end_tag": "# AGORA_BLOCK: end:contract_generate",
          "description": "Эндпоинт /contract/generate с шаблонами",
          "dependencies": [
            "contract_module",
            "contract_generator",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "10/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_negotiation": {
          "id": "ai_negotiation",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_negotiation",
          "end_tag": "# AGORA_BLOCK: end:ai_negotiation",
          "description": "Эндпоинт /ai/negotiation с контекстом",
          "dependencies": [
            "chat_module",
            "negotiation_orchestrator",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST",
            "GET"
          ],
          "auth_required": true,
          "rate_limit": "15/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_legal_template": {
          "id": "ai_legal_template",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_legal_template",
          "end_tag": "# AGORA_BLOCK: end:ai_legal_template",
          "description": "Эндпоинт /ai/legal_template по юрисдикциям",
          "dependencies": [
            "legal_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "10/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_translate": {
          "id": "ai_translate",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_translate",
          "end_tag": "# AGORA_BLOCK: end:ai_translate",
          "description": "Эндпоинт /ai/translate с контекстом",
          "dependencies": [
            "translation_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "30/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_risk_check": {
          "id": "ai_risk_check",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_risk_check",
          "end_tag": "# AGORA_BLOCK: end:ai_risk_check",
          "description": "Эндпоинт /ai/risk_check с аналитикой",
          "dependencies": [
            "risk_assessor_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "15/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_find_carrier": {
          "id": "ai_find_carrier",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_find_carrier",
          "end_tag": "# AGORA_BLOCK: end:ai_find_carrier",
          "description": "Эндпоинт /ai/find_carrier с фильтрацией",
          "dependencies": [
            "logistics_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "20/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "reputation_rating": {
          "id": "reputation_rating",
          "file": "src/api/reputation.py",
          "start_tag": "# AGORA_BLOCK: start:reputation_rating",
          "end_tag": "# AGORA_BLOCK: end:reputation_rating",
          "description": "Эндпоинт /reputation/rating с историей",
          "dependencies": [
            "reputation_system",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "GET"
          ],
          "auth_required": false,
          "rate_limit": "50/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "blockchain_register_match": {
          "id": "blockchain_register_match",
          "file": "src/api/blockchain.py",
          "start_tag": "# AGORA_BLOCK: start:blockchain_register_match",
          "end_tag": "# AGORA_BLOCK: end:blockchain_register_match",
          "description": "Эндпоинт /blockchain/register_match с гарантиями",
          "dependencies": [
            "blockchain_integration",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "10/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "integration_layer": {
      "description": "Integration Layer - внешние интеграции и сервисы",
      "modules": {
        "telegram_integration": {
          "id": "telegram_integration",
          "file": "src/integrations/telegram/telegramIntegration.py",
          "start_tag": "# AGORA_BLOCK: start:telegram_integration",
          "end_tag": "# AGORA_BLOCK: end:telegram_integration",
          "description": "Интеграция с Telegram API и Groups, обработка initData и управление сессиями",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "telegram.message.received",
            "telegram.callback.received",
            "telegram.session.updated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "cloudflare_integration": {
          "id": "cloudflare_integration",
          "file": "src/integrations/cloudflare/cloudflareIntegration.py",
          "start_tag": "# AGORA_BLOCK: start:cloudflare_integration",
          "end_tag": "# AGORA_BLOCK: end:cloudflare_integration",
          "description": "Интеграция с Cloudflare Workers и Pages",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "worker.request.received",
            "worker.response.sent"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_providers": {
          "id": "ai_providers",
          "file": "src/integrations/ai/aiProviders.py",
          "start_tag": "# AGORA_BLOCK: start:ai_providers",
          "end_tag": "# AGORA_BLOCK: end:ai_providers",
          "description": "Интеграция с AI-провайдерами (OpenAI, DeepSeek, Claude)",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "ai.request.sent",
            "ai.response.received"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "external_apis": {
          "id": "external_apis",
          "file": "src/integrations/external/externalApis.py",
          "start_tag": "# AGORA_BLOCK: start:external_apis",
          "end_tag": "# AGORA_BLOCK: end:external_apis",
          "description": "Интеграция с внешними API (KYC, логистика, платежи)",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "external.api.requested",
            "external.api.responded"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "blockchain_integration": {
          "id": "blockchain_integration",
          "file": "src/integrations/blockchain/blockchainIntegration.py",
          "start_tag": "# AGORA_BLOCK: start:blockchain_integration",
          "end_tag": "# AGORA_BLOCK: end:blockchain_integration",
          "description": "Интеграция с блокчейном (TON/Arweave) с гарантиями",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "blockchain.transaction.sent",
            "blockchain.transaction.confirmed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "infrastructure_layer": {
      "description": "Infrastructure Layer - инфраструктурные сервисы и утилиты",
      "modules": {
        "event_bus": {
          "id": "event_bus",
          "file": "src/infrastructure/events/eventBus.py",
          "start_tag": "# AGORA_BLOCK: start:event_bus",
          "end_tag": "# AGORA_BLOCK: end:event_bus",
          "description": "Event Bus для межмодульного взаимодействия",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "cache_service": {
          "id": "cache_service",
          "file": "src/infrastructure/cache/cacheService.py",
          "start_tag": "# AGORA_BLOCK: start:cache_service",
          "end_tag": "# AGORA_BLOCK: end:cache_service",
          "description": "Сервис кэширования с Redis и стратегиями для разных типов данных",
          "dependencies": [
            "event_bus"
          ],
          "events": [
            "cache.invalidated",
            "cache.cleared"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "translation_cache": {
          "id": "translation_cache",
          "file": "src/infrastructure/cache/strategies/translationCache.py",
          "start_tag": "# AGORA_BLOCK: start:translation_cache",
          "end_tag": "# AGORA_BLOCK: end:translation_cache",
          "description": "Кэш переводов с TTL и языковыми ключами",
          "dependencies": [
            "cache_service"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "embedding_cache": {
          "id": "embedding_cache",
          "file": "src/infrastructure/cache/strategies/embeddingCache.py",
          "start_tag": "# AGORA_BLOCK: start:embedding_cache",
          "end_tag": "# AGORA_BLOCK: end:embedding_cache",
          "description": "Кэш векторов по ID и типу запроса",
          "dependencies": [
            "cache_service"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "session_cache": {
          "id": "session_cache",
          "file": "src/infrastructure/cache/strategies/sessionCache.py",
          "start_tag": "# AGORA_BLOCK: start:session_cache",
          "end_tag": "# AGORA_BLOCK: end:session_cache",
          "description": "Кэш пользовательских сессий (например, токенов)",
          "dependencies": [
            "cache_service"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "storage_service": {
          "id": "storage_service",
          "file": "src/infrastructure/storage/storageService.py",
          "start_tag": "# AGORA_BLOCK: start:storage_service",
          "end_tag": "# AGORA_BLOCK: end:storage_service",
          "description": "Сервис хранения файлов (S3, IPFS, Arweave)",
          "dependencies": [
            "error_handler"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "monitoring_service": {
          "id": "monitoring_service",
          "file": "src/infrastructure/monitoring/monitoringService.py",
          "start_tag": "# AGORA_BLOCK: start:monitoring_service",
          "end_tag": "# AGORA_BLOCK: end:monitoring_service",
          "description": "Сервис мониторинга и логирования",
          "dependencies": [
            "event_bus"
          ],
          "events": [
            "metrics.recorded",
            "log.generated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "config_service": {
          "id": "config_service",
          "file": "src/infrastructure/config/configService.py",
          "start_tag": "# AGORA_BLOCK: start:config_service",
          "end_tag": "# AGORA_BLOCK: end:config_service",
          "description": "Сервис конфигурации и feature flags",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "error_handler": {
          "id": "error_handler",
          "file": "src/infrastructure/error/errorHandler.py",
          "start_tag": "# AGORA_BLOCK: start:error_handler",
          "end_tag": "# AGORA_BLOCK: end:error_handler",
          "description": "Централизованная обработка ошибок",
          "dependencies": [
            "monitoring_service"
          ],
          "events": [
            "error.occurred",
            "error.handled"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "circuit_breaker": {
          "id": "circuit_breaker",
          "file": "src/infrastructure/circuit/circuitBreaker.py",
          "start_tag": "# AGORA_BLOCK: start:circuit_breaker",
          "end_tag": "# AGORA_BLOCK: end:circuit_breaker",
          "description": "Circuit Breaker для отказоустойчивости",
          "dependencies": [
            "monitoring_service"
          ],
          "events": [
            "circuit.opened",
            "circuit.closed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "code_utils": {
          "id": "code_utils",
          "file": "src/utils/code_utils.py",
          "start_tag": "# AGORA_BLOCK: start:code_utils",
          "end_tag": "# AGORA_BLOCK: end:code_utils",
          "description": "Утилиты для работы с тегированными блоками кода",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "git_integration": {
          "id": "git_integration",
          "file": "src/utils/git_integration.py",
          "start_tag": "# AGORA_BLOCK: start:git_integration",
          "end_tag": "# AGORA_BLOCK: end:git_integration",
          "description": "Интеграция с Git для автоматического коммита изменений",
          "dependencies": [
            "code_utils"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "file_uploader": {
          "id": "file_uploader",
          "file": "src/services/fileUploader.ts",
          "start_tag": "// AGORA_BLOCK: start:file_uploader",
          "end_tag": "// AGORA_BLOCK: end:file_uploader",
          "description": "Загрузка и обработка файлов",
          "dependencies": [
            "storage_service",
            "error_handler"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "realtime_service": {
          "id": "realtime_service",
          "file": "src/services/realtimeService.ts",
          "start_tag": "// AGORA_BLOCK: start:realtime_service",
          "end_tag": "// AGORA_BLOCK: end:realtime_service",
          "description": "Real-time коммуникации через WebSocket",
          "dependencies": [
            "event_bus",
            "error_handler"
          ],
          "events": [
            "connection.established",
            "message.delivered"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "map_service": {
          "id": "map_service",
          "file": "src/services/mapService.ts",
          "start_tag": "// AGORA_BLOCK: start:map_service",
          "end_tag": "// AGORA_BLOCK: end:map_service",
          "description": "Работа с картами и геоданными",
          "dependencies": [
            "error_handler"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "ci_cd": {
      "description": "CI/CD Pipeline - GitHub Actions с заделом на ArgoCD",
      "modules": {
        "mvp_workflow": {
          "id": "mvp_workflow",
          "file": ".github/workflows/mvp.yml",
          "start_tag": "# AGORA_BLOCK: start:mvp_workflow",
          "end_tag": "# AGORA_BLOCK: end:mvp_workflow",
          "description": "Базовый CI/CD pipeline для MVP с автоматическими тестами",
          "dependencies": [
            "unit_tests",
            "integration_tests",
            "e2e_tests"
          ],
          "stages": [
            "test",
            "build",
            "deploy-staging",
            "deploy-production"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "config": {
      "description": "Environment Management - MVP с подготовкой к Vault",
      "modules": {
        "secret_manager": {
          "id": "secret_manager",
          "file": "src/core/config/secrets.ts",
          "start_tag": "// AGORA_BLOCK: start:secret_manager",
          "end_tag": "// AGORA_BLOCK: end:secret_manager",
          "description": "Управление секретами с заделом на Vault",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "database": {
      "description": "Database Strategy - PostgreSQL + Redis с партиционированием",
      "modules": {
        "initial_schema": {
          "id": "initial_schema",
          "file": "migrations/001_initial_schema.sql",
          "start_tag": "-- AGORA_BLOCK: start:initial_schema",
          "end_tag": "-- AGORA_BLOCK: end:initial_schema",
          "description": "Начальная схема БД для MVP",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "monitoring": {
      "description": "Monitoring Stack - Prometheus + Grafana с заделом на Jaeger",
      "modules": {
        "agora_metrics": {
          "id": "agora_metrics",
          "file": "backend/src/core/monitoring.py",
          "start_tag": "# AGORA_BLOCK: start:agora_metrics",
          "end_tag": "# AGORA_BLOCK: end:agora_metrics",
          "description": "Бизнес-метрики для MVP",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "testing": {
      "description": "Testing Strategy - Unit + Integration + E2E с оптимизацией CI/CD",
      "modules": {
        "unit_tests": {
          "id": "unit_tests",
          "file": "tests/unit/testSuite.py",
          "start_tag": "# AGORA_BLOCK: start:unit_tests",
          "end_tag": "# AGORA_BLOCK: end:unit_tests",
          "description": "Unit-тесты для бизнес-логики",
          "dependencies": [],
          "coverage": "85%",
          "conditional": true,
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "integration_tests": {
          "id": "integration_tests",
          "file": "tests/integration/testSuite.py",
          "start_tag": "# AGORA_BLOCK: start:integration_tests",
          "end_tag": "# AGORA_BLOCK: end:integration_tests",
          "description": "Интеграционные тесты для API",
          "dependencies": [],
          "coverage": "70%",
          "conditional": true,
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "e2e_tests": {
          "id": "e2e_tests",
          "file": "tests/e2e/testSuite.py",
          "start_tag": "# AGORA_BLOCK: start:e2e_tests",
          "end_tag": "# AGORA_BLOCK: end:e2e_tests",
          "description": "E2E-тесты для пользовательских сценариев",
          "dependencies": [],
          "coverage": "60%",
          "conditional": true,
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "performance_tests": {
          "id": "performance_tests",
          "file": "tests/performance/testSuite.py",
          "start_tag": "# AGORA_BLOCK: start:performance_tests",
          "end_tag": "# AGORA_BLOCK: end:performance_tests",
          "description": "Базовые тесты нагрузки для MVP",
          "dependencies": [],
          "conditional": false,
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    }
  }
}

================================================================================
ФАЙЛ: project_structure.txt
================================================================================
================================================================================
СТРУКТУРА ПРОЕКТА
================================================================================
Дата создания: 2025-08-07 18:54:13
Корневая директория: E:\2. Documents\Agora.AI\Project\Agora.AI
================================================================================

ИЕРАРХИЯ ПАПОК И ФАЙЛОВ:
----------------------------------------
├── docs/
│   └── architecture/
│       └── code_map.json
├── src/
│   ├── api/
│   │   └── auth.py
│   ├── infrastructure/
│   │   ├── error/
│   │   │   └── errorHandler.py
│   │   └── monitoring/
│   │       └── monitoringService.py
│   ├── integrations/
│   │   └── telegram/
│   │       └── telegramIntegration.py
│   ├── test/
│   │   ├── test_file.py
│   │   └── test_utilities.py
│   ├── utils/
│   │   ├── .gitkeep
│   │   ├── code_utils.py
│   │   ├── git_integration.py
│   │   ├── interactive_update.py
│   │   ├── project_structure_exporter.py
│   │   └── update_code.py
│   └── main.py
├── .env
├── .gitignore
├── README.md
├── app.py
└── test_env.py

================================================================================

СОДЕРЖИМОЕ ФАЙЛОВ:
----------------------------------------

================================================================================
ФАЙЛ: .env
================================================================================
[БИНАРНЫЙ ФАЙЛ - СОДЕРЖИМОЕ НЕ ПРОЧИТАНО]

================================================================================
ФАЙЛ: .gitignore
================================================================================
[БИНАРНЫЙ ФАЙЛ - СОДЕРЖИМОЕ НЕ ПРОЧИТАНО]

================================================================================
ФАЙЛ: README.md
================================================================================
# Agora.AI
Agora-AI

================================================================================
ФАЙЛ: app.py
================================================================================
# AGORA_BLOCK: start:app
import sys
import os

# Добавляем корневую директорию проекта в sys.path
sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))

# Импортируем приложение из src
from src.main import app

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
# AGORA_BLOCK: end:app

================================================================================
ФАЙЛ: docs\architecture\code_map.json
================================================================================
{
  "metadata": {
    "project": "Agora.AI",
    "version": "1.0.0",
    "last_updated": "2023-11-15T00:00:00Z",
    "description": "Финальная кодовая карта для MVP с масштабируемостью",
    "architecture": "3-layer with event-driven communication",
    "mvp_ready": true,
    "scalable": true,
    "error_handling": "centralized",
    "caching": "transparent",
    "testing": "automated"
  },
  "layers": {
    "ui_layer": {
      "description": "UI Layer (Presentation) - компоненты интерфейса с поддержкой мультиплатформенности",
      "modules": {
        "auth_module": {
          "id": "auth_module",
          "file": "src/ui/auth.module.ts",
          "start_tag": "// AGORA_BLOCK: start:auth_module",
          "end_tag": "// AGORA_BLOCK: end:auth_module",
          "description": "Авторизация через Telegram и в будущем через email/web",
          "dependencies": [
            "api_service",
            "error_handler",
            "telegram_integration"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "auth.success",
            "auth.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "company_profile_module": {
          "id": "company_profile_module",
          "file": "src/ui/companyProfile.module.ts",
          "start_tag": "// AGORA_BLOCK: start:company_profile_module",
          "end_tag": "// AGORA_BLOCK: end:company_profile_module",
          "description": "UI-модуль для редактирования профиля компании",
          "dependencies": [
            "api_service",
            "file_uploader",
            "error_handler",
            "profile_manager"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "profile.updated",
            "profile.created"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "swipe_cards_module": {
          "id": "swipe_cards_module",
          "file": "src/ui/swipeCards.module.ts",
          "start_tag": "// AGORA_BLOCK: start:swipe_cards_module",
          "end_tag": "// AGORA_BLOCK: end:swipe_cards_module",
          "description": "Основная лента свайпов (Tinder-like интерфейс) с анимациями",
          "dependencies": [
            "api_service",
            "match_engine",
            "cache_service",
            "error_handler",
            "card_manager"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "swipe.performed",
            "match.found",
            "match.processed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "logistics_module": {
          "id": "logistics_module",
          "file": "src/ui/logistics.module.ts",
          "start_tag": "// AGORA_BLOCK: start:logistics_module",
          "end_tag": "// AGORA_BLOCK: end:logistics_module",
          "description": "Карта логистики и визуализация маршрутов с интерактивными элементами",
          "dependencies": [
            "api_service",
            "logistics_ai",
            "map_service",
            "error_handler"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "route.optimized",
            "route.selected"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "chat_module": {
          "id": "chat_module",
          "file": "src/ui/chat.module.ts",
          "start_tag": "// AGORA_BLOCK: start:chat_module",
          "end_tag": "// AGORA_BLOCK: end:chat_module",
          "description": "Чат-переговоры между компаниями с поддержкой медиа и документов",
          "dependencies": [
            "api_service",
            "negotiation_orchestrator",
            "realtime_service",
            "error_handler"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "message.sent",
            "message.received",
            "negotiation.updated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "contract_module": {
          "id": "contract_module",
          "file": "src/ui/contract.module.ts",
          "start_tag": "// AGORA_BLOCK: start:contract_module",
          "end_tag": "// AGORA_BLOCK: end:contract_module",
          "description": "Генерация и подписание договоров с электронной подписью",
          "dependencies": [
            "api_service",
            "contract_generator",
            "blockchain_integration",
            "esign_service",
            "error_handler"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "contract.generated",
            "contract.signed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "settings_module": {
          "id": "settings_module",
          "file": "src/ui/settings.module.ts",
          "start_tag": "// AGORA_BLOCK: start:settings_module",
          "end_tag": "// AGORA_BLOCK: end:settings_module",
          "description": "Настройки языка, уведомлений и профиля с темой",
          "dependencies": [
            "api_service",
            "translation_ai",
            "storage_service",
            "error_handler"
          ],
          "platforms": [
            "telegram",
            "web",
            "ios"
          ],
          "events": [
            "settings.updated",
            "language.changed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "business_logic_layer": {
      "description": "Business Logic Layer - ядро бизнес-логики с event-driven архитектурой",
      "modules": {
        "profile_manager": {
          "id": "profile_manager",
          "file": "src/business/profileManager.py",
          "start_tag": "# AGORA_BLOCK: start:profile_manager",
          "end_tag": "# AGORA_BLOCK: end:profile_manager",
          "description": "Статическая информация о компании, которую заполняет и обновляет пользователь",
          "dependencies": [
            "error_handler",
            "monitoring_service",
            "kyc_verifier"
          ],
          "events": [
            "profile.updated",
            "profile.verified"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "card_manager": {
          "id": "card_manager",
          "file": "src/business/cardManager.py",
          "start_tag": "# AGORA_BLOCK: start:card_manager",
          "end_tag": "# AGORA_BLOCK: end:card_manager",
          "description": "Динамические карточки, создаваемые под конкретный товар/услугу и категорию",
          "dependencies": [
            "profile_manager",
            "product_catalog",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "card.created",
            "card.updated",
            "card.archived"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "product_catalog": {
          "id": "product_catalog",
          "file": "src/business/productCatalog.py",
          "start_tag": "# AGORA_BLOCK: start:product_catalog",
          "end_tag": "# AGORA_BLOCK: end:product_catalog",
          "description": "Каталог товаров компании с категориями и характеристиками",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "product.added",
            "product.updated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "match_engine": {
          "id": "match_engine",
          "file": "src/business/matchEngine.py",
          "start_tag": "# AGORA_BLOCK: start:match_engine",
          "end_tag": "# AGORA_BLOCK: end:match_engine",
          "description": "Ищет подходящие карточки, взаимодействует с AI и фильтрует по категории/роли",
          "dependencies": [
            "card_manager",
            "embedding_service",
            "translation_ai",
            "cache_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "match.found",
            "match.processed",
            "match.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "negotiator_agent_a": {
          "id": "negotiator_agent_a",
          "file": "src/business/ai/negotiatorAgentA.py",
          "start_tag": "# AGORA_BLOCK: start:negotiator_agent_a",
          "end_tag": "# AGORA_BLOCK: end:negotiator_agent_a",
          "description": "AI-переговорщик от компании A (внутренний или внешний)",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "negotiation.message.a"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "negotiator_agent_b": {
          "id": "negotiator_agent_b",
          "file": "src/business/ai/negotiatorAgentB.py",
          "start_tag": "# AGORA_BLOCK: start:negotiator_agent_b",
          "end_tag": "# AGORA_BLOCK: end:negotiator_agent_b",
          "description": "AI-переговорщик от компании B (внутренний или внешний)",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "negotiation.message.b"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "gatekeeper_agent": {
          "id": "gatekeeper_agent",
          "file": "src/business/ai/gatekeeperAgent.py",
          "start_tag": "# AGORA_BLOCK: start:gatekeeper_agent",
          "end_tag": "# AGORA_BLOCK: end:gatekeeper_agent",
          "description": "Агент-Вышибала: проверяет соответствие сообщений правилам",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "gatekeeper.check",
            "gatekeeper.block"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "auditor_agent": {
          "id": "auditor_agent",
          "file": "src/business/ai/auditorAgent.py",
          "start_tag": "# AGORA_BLOCK: start:auditor_agent",
          "end_tag": "# AGORA_BLOCK: end:auditor_agent",
          "description": "Агент-Аудитор: проверяет финальный договор на логические/юридические ошибки",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "audit.completed",
            "audit.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "negotiation_orchestrator": {
          "id": "negotiation_orchestrator",
          "file": "src/business/negotiationOrchestrator.py",
          "start_tag": "# AGORA_BLOCK: start:negotiation_orchestrator",
          "end_tag": "# AGORA_BLOCK: end:negotiation_orchestrator",
          "description": "Оркестратор: управляет сценарием переговоров и вызывает нужных агентов",
          "dependencies": [
            "negotiator_agent_a",
            "negotiator_agent_b",
            "gatekeeper_agent",
            "auditor_agent",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "negotiation.started",
            "negotiation.completed",
            "negotiation.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "contract_generator": {
          "id": "contract_generator",
          "file": "src/business/contractGenerator.py",
          "start_tag": "# AGORA_BLOCK: start:contract_generator",
          "end_tag": "# AGORA_BLOCK: end:contract_generator",
          "description": "Генерация юридических документов с шаблонами и AI",
          "dependencies": [
            "legal_ai",
            "translation_ai",
            "template_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "contract.generated",
            "contract.signed",
            "contract.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "reputation_system": {
          "id": "reputation_system",
          "file": "src/business/reputationSystem.py",
          "start_tag": "# AGORA_BLOCK: start:reputation_system",
          "end_tag": "# AGORA_BLOCK: end:reputation_system",
          "description": "Система репутации и рейтингов компаний с AI-анализом",
          "dependencies": [
            "kyc_verifier",
            "blockchain_integration",
            "cache_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "reputation.updated",
            "reputation.reviewed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "kyc_verifier": {
          "id": "kyc_verifier",
          "file": "src/business/kycVerifier.py",
          "start_tag": "# AGORA_BLOCK: start:kyc_verifier",
          "end_tag": "# AGORA_BLOCK: end:kyc_verifier",
          "description": "Проверка KYC и верификация компаний с интеграцией сервисов",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "kyc.started",
            "kyc.completed",
            "kyc.failed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "logistics_finder": {
          "id": "logistics_finder",
          "file": "src/business/logisticsFinder.py",
          "start_tag": "# AGORA_BLOCK: start:logistics_finder",
          "end_tag": "# AGORA_BLOCK: end:logistics_finder",
          "description": "Поиск логистических решений и перевозчиков с оптимизацией",
          "dependencies": [
            "logistics_ai",
            "cache_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "logistics.requested",
            "logistics.optimized"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "legal_ai": {
          "id": "legal_ai",
          "file": "src/business/legalAI.py",
          "start_tag": "# AGORA_BLOCK: start:legal_ai",
          "end_tag": "# AGORA_BLOCK: end:legal_ai",
          "description": "AI-юрист для генерации шаблонов договоров по юрисдикциям",
          "dependencies": [
            "translation_ai",
            "template_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "legal.advice.requested",
            "legal.template.generated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "logistics_ai": {
          "id": "logistics_ai",
          "file": "src/business/logisticsAI.py",
          "start_tag": "# AGORA_BLOCK: start:logistics_ai",
          "end_tag": "# AGORA_BLOCK: end:logistics_ai",
          "description": "Анализ логистических маршрутов и узлов с AI-оптимизацией",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "route.analyzed",
            "route.optimized"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "translation_ai": {
          "id": "translation_ai",
          "file": "src/business/translationAI.py",
          "start_tag": "# AGORA_BLOCK: start:translation_ai",
          "end_tag": "# AGORA_BLOCK: end:translation_ai",
          "description": "Адаптация текстов под языки и бизнес-культуру с контекстом",
          "dependencies": [
            "cache_service",
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "translation.requested",
            "translation.completed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "risk_assessor_ai": {
          "id": "risk_assessor_ai",
          "file": "src/business/riskAssessorAI.py",
          "start_tag": "# AGORA_BLOCK: start:risk_assessor_ai",
          "end_tag": "# AGORA_BLOCK: end:risk_assessor_ai",
          "description": "Проверка страновых и контрагентных рисков с AI-анализом",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "risk.assessed",
            "risk.alert"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "test_block": {
          "id": "test_block",
          "file": "src/test/test_file.py",
          "start_tag": "# AGORA_BLOCK: start:test_block",
          "end_tag": "# AGORA_BLOCK: end:test_block",
          "description": "Тестовый блок для проверки утилит",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.2",
          "last_modified": "2025-08-07T18:15:03.893057"
        },
        "embedding_service": {
          "id": "embedding_service",
          "file": "src/business/embeddingService.py",
          "start_tag": "# AGORA_BLOCK: start:embedding_service",
          "end_tag": "# AGORA_BLOCK: end:embedding_service",
          "description": "Сервис для работы с embedding-векторами и семантическим поиском",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "embedding.generated",
            "embedding.searched"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "api_layer": {
      "description": "API Layer (Gateway) - точки входа для фронтенда с валидацией",
      "modules": {
        "auth_login": {
          "id": "auth_login",
          "file": "src/api/auth.py",
          "start_tag": "# AGORA_BLOCK: start:auth_login",
          "end_tag": "# AGORA_BLOCK: end:auth_login",
          "description": "Эндпоинт /auth/login с валидацией и безопасностью",
          "dependencies": [
            "auth_module",
            "telegram_integration",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": false,
          "rate_limit": "5/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "profile_create": {
          "id": "profile_create",
          "file": "src/api/profile.py",
          "start_tag": "# AGORA_BLOCK: start:profile_create",
          "end_tag": "# AGORA_BLOCK: end:profile_create",
          "description": "Эндпоинт /profile/create с валидацией данных",
          "dependencies": [
            "company_profile_module",
            "profile_manager",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "10/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "match_swipe": {
          "id": "match_swipe",
          "file": "src/api/match.py",
          "start_tag": "# AGORA_BLOCK: start:match_swipe",
          "end_tag": "# AGORA_BLOCK: end:match_swipe",
          "description": "Эндпоинт /match/swipe с обработкой в реальном времени",
          "dependencies": [
            "swipe_cards_module",
            "match_engine",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "30/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "logistics_map": {
          "id": "logistics_map",
          "file": "src/api/logistics.py",
          "start_tag": "# AGORA_BLOCK: start:logistics_map",
          "end_tag": "# AGORA_BLOCK: end:logistics_map",
          "description": "Эндпоинт /logistics/map с геоданными",
          "dependencies": [
            "logistics_module",
            "logistics_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "GET",
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "20/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "contract_generate": {
          "id": "contract_generate",
          "file": "src/api/contract.py",
          "start_tag": "# AGORA_BLOCK: start:contract_generate",
          "end_tag": "# AGORA_BLOCK: end:contract_generate",
          "description": "Эндпоинт /contract/generate с шаблонами",
          "dependencies": [
            "contract_module",
            "contract_generator",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "10/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_negotiation": {
          "id": "ai_negotiation",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_negotiation",
          "end_tag": "# AGORA_BLOCK: end:ai_negotiation",
          "description": "Эндпоинт /ai/negotiation с контекстом",
          "dependencies": [
            "chat_module",
            "negotiation_orchestrator",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST",
            "GET"
          ],
          "auth_required": true,
          "rate_limit": "15/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_legal_template": {
          "id": "ai_legal_template",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_legal_template",
          "end_tag": "# AGORA_BLOCK: end:ai_legal_template",
          "description": "Эндпоинт /ai/legal_template по юрисдикциям",
          "dependencies": [
            "legal_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "10/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_translate": {
          "id": "ai_translate",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_translate",
          "end_tag": "# AGORA_BLOCK: end:ai_translate",
          "description": "Эндпоинт /ai/translate с контекстом",
          "dependencies": [
            "translation_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "30/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_risk_check": {
          "id": "ai_risk_check",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_risk_check",
          "end_tag": "# AGORA_BLOCK: end:ai_risk_check",
          "description": "Эндпоинт /ai/risk_check с аналитикой",
          "dependencies": [
            "risk_assessor_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "15/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_find_carrier": {
          "id": "ai_find_carrier",
          "file": "src/api/ai.py",
          "start_tag": "# AGORA_BLOCK: start:ai_find_carrier",
          "end_tag": "# AGORA_BLOCK: end:ai_find_carrier",
          "description": "Эндпоинт /ai/find_carrier с фильтрацией",
          "dependencies": [
            "logistics_ai",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "20/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "reputation_rating": {
          "id": "reputation_rating",
          "file": "src/api/reputation.py",
          "start_tag": "# AGORA_BLOCK: start:reputation_rating",
          "end_tag": "# AGORA_BLOCK: end:reputation_rating",
          "description": "Эндпоинт /reputation/rating с историей",
          "dependencies": [
            "reputation_system",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "GET"
          ],
          "auth_required": false,
          "rate_limit": "50/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "blockchain_register_match": {
          "id": "blockchain_register_match",
          "file": "src/api/blockchain.py",
          "start_tag": "# AGORA_BLOCK: start:blockchain_register_match",
          "end_tag": "# AGORA_BLOCK: end:blockchain_register_match",
          "description": "Эндпоинт /blockchain/register_match с гарантиями",
          "dependencies": [
            "blockchain_integration",
            "error_handler",
            "cache_service",
            "circuit_breaker"
          ],
          "methods": [
            "POST"
          ],
          "auth_required": true,
          "rate_limit": "10/min",
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "integration_layer": {
      "description": "Integration Layer - внешние интеграции и сервисы",
      "modules": {
        "telegram_integration": {
          "id": "telegram_integration",
          "file": "src/integrations/telegram/telegramIntegration.py",
          "start_tag": "# AGORA_BLOCK: start:telegram_integration",
          "end_tag": "# AGORA_BLOCK: end:telegram_integration",
          "description": "Интеграция с Telegram API и Groups, обработка initData и управление сессиями",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "telegram.message.received",
            "telegram.callback.received",
            "telegram.session.updated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "cloudflare_integration": {
          "id": "cloudflare_integration",
          "file": "src/integrations/cloudflare/cloudflareIntegration.py",
          "start_tag": "# AGORA_BLOCK: start:cloudflare_integration",
          "end_tag": "# AGORA_BLOCK: end:cloudflare_integration",
          "description": "Интеграция с Cloudflare Workers и Pages",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "worker.request.received",
            "worker.response.sent"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "ai_providers": {
          "id": "ai_providers",
          "file": "src/integrations/ai/aiProviders.py",
          "start_tag": "# AGORA_BLOCK: start:ai_providers",
          "end_tag": "# AGORA_BLOCK: end:ai_providers",
          "description": "Интеграция с AI-провайдерами (OpenAI, DeepSeek, Claude)",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "ai.request.sent",
            "ai.response.received"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "external_apis": {
          "id": "external_apis",
          "file": "src/integrations/external/externalApis.py",
          "start_tag": "# AGORA_BLOCK: start:external_apis",
          "end_tag": "# AGORA_BLOCK: end:external_apis",
          "description": "Интеграция с внешними API (KYC, логистика, платежи)",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "external.api.requested",
            "external.api.responded"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "blockchain_integration": {
          "id": "blockchain_integration",
          "file": "src/integrations/blockchain/blockchainIntegration.py",
          "start_tag": "# AGORA_BLOCK: start:blockchain_integration",
          "end_tag": "# AGORA_BLOCK: end:blockchain_integration",
          "description": "Интеграция с блокчейном (TON/Arweave) с гарантиями",
          "dependencies": [
            "error_handler",
            "monitoring_service"
          ],
          "events": [
            "blockchain.transaction.sent",
            "blockchain.transaction.confirmed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "infrastructure_layer": {
      "description": "Infrastructure Layer - инфраструктурные сервисы и утилиты",
      "modules": {
        "event_bus": {
          "id": "event_bus",
          "file": "src/infrastructure/events/eventBus.py",
          "start_tag": "# AGORA_BLOCK: start:event_bus",
          "end_tag": "# AGORA_BLOCK: end:event_bus",
          "description": "Event Bus для межмодульного взаимодействия",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "cache_service": {
          "id": "cache_service",
          "file": "src/infrastructure/cache/cacheService.py",
          "start_tag": "# AGORA_BLOCK: start:cache_service",
          "end_tag": "# AGORA_BLOCK: end:cache_service",
          "description": "Сервис кэширования с Redis и стратегиями для разных типов данных",
          "dependencies": [
            "event_bus"
          ],
          "events": [
            "cache.invalidated",
            "cache.cleared"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "translation_cache": {
          "id": "translation_cache",
          "file": "src/infrastructure/cache/strategies/translationCache.py",
          "start_tag": "# AGORA_BLOCK: start:translation_cache",
          "end_tag": "# AGORA_BLOCK: end:translation_cache",
          "description": "Кэш переводов с TTL и языковыми ключами",
          "dependencies": [
            "cache_service"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "embedding_cache": {
          "id": "embedding_cache",
          "file": "src/infrastructure/cache/strategies/embeddingCache.py",
          "start_tag": "# AGORA_BLOCK: start:embedding_cache",
          "end_tag": "# AGORA_BLOCK: end:embedding_cache",
          "description": "Кэш векторов по ID и типу запроса",
          "dependencies": [
            "cache_service"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "session_cache": {
          "id": "session_cache",
          "file": "src/infrastructure/cache/strategies/sessionCache.py",
          "start_tag": "# AGORA_BLOCK: start:session_cache",
          "end_tag": "# AGORA_BLOCK: end:session_cache",
          "description": "Кэш пользовательских сессий (например, токенов)",
          "dependencies": [
            "cache_service"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "storage_service": {
          "id": "storage_service",
          "file": "src/infrastructure/storage/storageService.py",
          "start_tag": "# AGORA_BLOCK: start:storage_service",
          "end_tag": "# AGORA_BLOCK: end:storage_service",
          "description": "Сервис хранения файлов (S3, IPFS, Arweave)",
          "dependencies": [
            "error_handler"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "monitoring_service": {
          "id": "monitoring_service",
          "file": "src/infrastructure/monitoring/monitoringService.py",
          "start_tag": "# AGORA_BLOCK: start:monitoring_service",
          "end_tag": "# AGORA_BLOCK: end:monitoring_service",
          "description": "Сервис мониторинга и логирования",
          "dependencies": [
            "event_bus"
          ],
          "events": [
            "metrics.recorded",
            "log.generated"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "config_service": {
          "id": "config_service",
          "file": "src/infrastructure/config/configService.py",
          "start_tag": "# AGORA_BLOCK: start:config_service",
          "end_tag": "# AGORA_BLOCK: end:config_service",
          "description": "Сервис конфигурации и feature flags",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "error_handler": {
          "id": "error_handler",
          "file": "src/infrastructure/error/errorHandler.py",
          "start_tag": "# AGORA_BLOCK: start:error_handler",
          "end_tag": "# AGORA_BLOCK: end:error_handler",
          "description": "Централизованная обработка ошибок",
          "dependencies": [
            "monitoring_service"
          ],
          "events": [
            "error.occurred",
            "error.handled"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "circuit_breaker": {
          "id": "circuit_breaker",
          "file": "src/infrastructure/circuit/circuitBreaker.py",
          "start_tag": "# AGORA_BLOCK: start:circuit_breaker",
          "end_tag": "# AGORA_BLOCK: end:circuit_breaker",
          "description": "Circuit Breaker для отказоустойчивости",
          "dependencies": [
            "monitoring_service"
          ],
          "events": [
            "circuit.opened",
            "circuit.closed"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "code_utils": {
          "id": "code_utils",
          "file": "src/utils/code_utils.py",
          "start_tag": "# AGORA_BLOCK: start:code_utils",
          "end_tag": "# AGORA_BLOCK: end:code_utils",
          "description": "Утилиты для работы с тегированными блоками кода",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "git_integration": {
          "id": "git_integration",
          "file": "src/utils/git_integration.py",
          "start_tag": "# AGORA_BLOCK: start:git_integration",
          "end_tag": "# AGORA_BLOCK: end:git_integration",
          "description": "Интеграция с Git для автоматического коммита изменений",
          "dependencies": [
            "code_utils"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "file_uploader": {
          "id": "file_uploader",
          "file": "src/services/fileUploader.ts",
          "start_tag": "// AGORA_BLOCK: start:file_uploader",
          "end_tag": "// AGORA_BLOCK: end:file_uploader",
          "description": "Загрузка и обработка файлов",
          "dependencies": [
            "storage_service",
            "error_handler"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "realtime_service": {
          "id": "realtime_service",
          "file": "src/services/realtimeService.ts",
          "start_tag": "// AGORA_BLOCK: start:realtime_service",
          "end_tag": "// AGORA_BLOCK: end:realtime_service",
          "description": "Real-time коммуникации через WebSocket",
          "dependencies": [
            "event_bus",
            "error_handler"
          ],
          "events": [
            "connection.established",
            "message.delivered"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "map_service": {
          "id": "map_service",
          "file": "src/services/mapService.ts",
          "start_tag": "// AGORA_BLOCK: start:map_service",
          "end_tag": "// AGORA_BLOCK: end:map_service",
          "description": "Работа с картами и геоданными",
          "dependencies": [
            "error_handler"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "ci_cd": {
      "description": "CI/CD Pipeline - GitHub Actions с заделом на ArgoCD",
      "modules": {
        "mvp_workflow": {
          "id": "mvp_workflow",
          "file": ".github/workflows/mvp.yml",
          "start_tag": "# AGORA_BLOCK: start:mvp_workflow",
          "end_tag": "# AGORA_BLOCK: end:mvp_workflow",
          "description": "Базовый CI/CD pipeline для MVP с автоматическими тестами",
          "dependencies": [
            "unit_tests",
            "integration_tests",
            "e2e_tests"
          ],
          "stages": [
            "test",
            "build",
            "deploy-staging",
            "deploy-production"
          ],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "config": {
      "description": "Environment Management - MVP с подготовкой к Vault",
      "modules": {
        "secret_manager": {
          "id": "secret_manager",
          "file": "src/core/config/secrets.ts",
          "start_tag": "// AGORA_BLOCK: start:secret_manager",
          "end_tag": "// AGORA_BLOCK: end:secret_manager",
          "description": "Управление секретами с заделом на Vault",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "database": {
      "description": "Database Strategy - PostgreSQL + Redis с партиционированием",
      "modules": {
        "initial_schema": {
          "id": "initial_schema",
          "file": "migrations/001_initial_schema.sql",
          "start_tag": "-- AGORA_BLOCK: start:initial_schema",
          "end_tag": "-- AGORA_BLOCK: end:initial_schema",
          "description": "Начальная схема БД для MVP",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "monitoring": {
      "description": "Monitoring Stack - Prometheus + Grafana с заделом на Jaeger",
      "modules": {
        "agora_metrics": {
          "id": "agora_metrics",
          "file": "backend/src/core/monitoring.py",
          "start_tag": "# AGORA_BLOCK: start:agora_metrics",
          "end_tag": "# AGORA_BLOCK: end:agora_metrics",
          "description": "Бизнес-метрики для MVP",
          "dependencies": [],
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    },
    "testing": {
      "description": "Testing Strategy - Unit + Integration + E2E с оптимизацией CI/CD",
      "modules": {
        "unit_tests": {
          "id": "unit_tests",
          "file": "tests/unit/testSuite.py",
          "start_tag": "# AGORA_BLOCK: start:unit_tests",
          "end_tag": "# AGORA_BLOCK: end:unit_tests",
          "description": "Unit-тесты для бизнес-логики",
          "dependencies": [],
          "coverage": "85%",
          "conditional": true,
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "integration_tests": {
          "id": "integration_tests",
          "file": "tests/integration/testSuite.py",
          "start_tag": "# AGORA_BLOCK: start:integration_tests",
          "end_tag": "# AGORA_BLOCK: end:integration_tests",
          "description": "Интеграционные тесты для API",
          "dependencies": [],
          "coverage": "70%",
          "conditional": true,
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "e2e_tests": {
          "id": "e2e_tests",
          "file": "tests/e2e/testSuite.py",
          "start_tag": "# AGORA_BLOCK: start:e2e_tests",
          "end_tag": "# AGORA_BLOCK: end:e2e_tests",
          "description": "E2E-тесты для пользовательских сценариев",
          "dependencies": [],
          "coverage": "60%",
          "conditional": true,
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        },
        "performance_tests": {
          "id": "performance_tests",
          "file": "tests/performance/testSuite.py",
          "start_tag": "# AGORA_BLOCK: start:performance_tests",
          "end_tag": "# AGORA_BLOCK: end:performance_tests",
          "description": "Базовые тесты нагрузки для MVP",
          "dependencies": [],
          "conditional": false,
          "author": "AI_Assistant",
          "version": "1.0.0",
          "last_modified": "2023-11-15T00:00:00Z"
        }
      }
    }
  }
}

================================================================================
ФАЙЛ: src\api\auth.py
================================================================================
# AGORA_BLOCK: start:auth_login
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBearer
from pydantic import BaseModel
from typing import Dict, Any
import jwt
import datetime
import os
from src.integrations.telegram.telegramIntegration import telegram_integration
from src.infrastructure.error.errorHandler import ErrorHandler
from src.infrastructure.monitoring.monitoringService import monitoring_service

router = APIRouter()
security = HTTPBearer()

class LoginRequest(BaseModel):
    """Модель запроса на вход"""
    init_data: str

class LoginResponse(BaseModel):
    """Модель ответа при успешном входе"""
    access_token: str
    token_type: str = "bearer"
    expires_in: int

@router.post("/auth/login", response_model=LoginResponse)
async def login(request: LoginRequest):
    """
    Эндпоинт для аутентификации через Telegram
    
    Args:
        request: Данные для входа
        
    Returns:
        JWT токен для доступа к API
        
    Raises:
        HTTPException: При ошибках аутентификации
    """
    try:
        # Валидация initData от Telegram
        user_data = await telegram_integration.validate_init_data(request.init_data)
        
        # Получение информации о пользователе
        telegram_id = int(user_data.get('user', {}).get('id'))
        user_info = await telegram_integration.get_user_info(telegram_id)
        
        if not user_info:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Пользователь не найден"
            )
        
        # Создание JWT токена
        payload = {
            "sub": str(telegram_id),
            "user_info": user_info,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=24)
        }
        
        token = jwt.encode(
            payload,
            os.getenv("JWT_SECRET", "your-secret-key"),
            algorithm="HS256"
        )
        
        # Логирование успешного входа
        monitoring_service.log_event("auth.success", {"user_id": telegram_id})
        
        return LoginResponse(
            access_token=token,
            expires_in=24 * 60 * 60  # 24 часа в секундах
        )
        
    except Exception as e:
        # Логирование ошибки
        ErrorHandler.handle_error(e, "auth.login")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Ошибка аутентификации"
        )

@router.get("/auth/me")
async def get_current_user(token: str = Depends(security)):
    """
    Получение информации о текущем пользователе
    
    Args:
        token: JWT токен
        
    Returns:
        Информация о пользователе
        
    Raises:
        HTTPException: При ошибках валидации токена
    """
    try:
        # Декодирование токена
        payload = jwt.decode(
            token.credentials,
            os.getenv("JWT_SECRET", "your-secret-key"),
            algorithms=["HS256"]
        )
        
        return payload.get("user_info")
        
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Токен истек"
        )
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Невалидный токен"
        )
# AGORA_BLOCK: end:auth_login

================================================================================
ФАЙЛ: src\infrastructure\error\errorHandler.py
================================================================================
# AGORA_BLOCK: start:error_handler
import logging
import traceback
from typing import Any, Dict, Optional

logger = logging.getLogger(__name__)

class ErrorHandler:
    """Централизованная обработка ошибок"""
    
    @staticmethod
    def handle_error(error: Exception, context: str = "") -> Dict[str, Any]:
        """
        Обработка ошибки и возврат структурированного ответа
        
        Args:
            error: Исключение
            context: Контекст возникновения ошибки
            
        Returns:
            Словарь с информацией об ошибке
        """
        error_info = {
            "error_type": type(error).__name__,
            "error_message": str(error),
            "context": context,
            "traceback": traceback.format_exc()
        }
        
        # Логирование ошибки
        logger.error(f"Ошибка в контексте '{context}': {error_info}")
        
        return error_info
    
    @staticmethod
    def log_error(error: Exception, context: str = "") -> None:
        """
        Логирование ошибки без возврата информации
        
        Args:
            error: Исключение
            context: Контекст возникновения ошибки
        """
        logger.error(f"Ошибка в контексте '{context}': {type(error).__name__}: {error}")
# AGORA_BLOCK: end:error_handler

================================================================================
ФАЙЛ: src\infrastructure\monitoring\monitoringService.py
================================================================================
# AGORA_BLOCK: start:monitoring_service
import logging
import time
from typing import Any, Dict, Optional
from prometheus_client import Counter, Histogram, Gauge, start_http_server

logger = logging.getLogger(__name__)

class MonitoringService:
    """Сервис мониторинга и логирования"""
    
    def __init__(self, port: int = 8001):
        # Запуск Prometheus метрик
        start_http_server(port)
        
        # Основные метрики
        self.api_requests = Counter('agora_api_requests_total', 'API requests', ['endpoint', 'method', 'status'])
        self.api_errors = Counter('agora_api_errors_total', 'API errors', ['endpoint', 'status'])
        self.active_negotiations = Gauge('agora_active_negotiations', 'Active negotiations count')
        self.successful_matches = Counter('agora_successful_matches_total', 'Successful matches count')
        self.request_duration = Histogram('agora_request_duration_seconds', 'Request duration')
        
        logger.info(f"Monitoring service started on port {port}")
    
    def log_event(self, event_name: str, data: Optional[Dict[str, Any]] = None) -> None:
        """
        Логирование события
        
        Args:
            event_name: Название события
            data: Дополнительные данные
        """
        if data:
            logger.info(f"Event: {event_name}, Data: {data}")
        else:
            logger.info(f"Event: {event_name}")
    
    def increment_api_requests(self, endpoint: str, method: str, status: int) -> None:
        """
        Увеличение счетчика API запросов
        
        Args:
            endpoint: Эндпоинт
            method: HTTP метод
            status: HTTP статус
        """
        self.api_requests.labels(endpoint=endpoint, method=method, status=status).inc()
    
    def increment_api_errors(self, endpoint: str, status: int) -> None:
        """
        Увеличение счетчика ошибок API
        
        Args:
            endpoint: Эндпоинт
            status: HTTP статус
        """
        self.api_errors.labels(endpoint=endpoint, status=status).inc()
    
    def track_negotiation_start(self) -> None:
        """Отслеживание начала переговоров"""
        self.active_negotiations.inc()
    
    def track_negotiation_end(self, success: bool = True) -> None:
        """
        Отслеживание окончания переговоров
        
        Args:
            success: Успешность переговоров
        """
        self.active_negotiations.dec()
        if success:
            self.successful_matches.inc()
    
    def track_request_duration(self, duration: float) -> None:
        """
        Отслеживание длительности запроса
        
        Args:
            duration: Длительность в секундах
        """
        self.request_duration.observe(duration)

# Создаем экземпляр сервиса
monitoring_service = MonitoringService()
# AGORA_BLOCK: end:monitoring_service

================================================================================
ФАЙЛ: src\integrations\telegram\telegramIntegration.py
================================================================================
# AGORA_BLOCK: start:telegram_integration
import os
import hashlib
import hmac
import json
from typing import Dict, Optional, Any
from fastapi import HTTPException, status
from pydantic import BaseModel, validator
import httpx
import logging
from dotenv import load_dotenv

# Загружаем переменные окружения
load_dotenv()

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TelegramInitData(BaseModel):
    """Модель для валидации initData от Telegram"""
    query_id: str
    user: Dict[str, Any]
    auth_date: int
    hash: str

    @validator('hash')
    def validate_hash(cls, v, values):
        # Временно пропускаем валидацию для разработки
        return v

class TelegramIntegration:
    """Интеграция с Telegram API и обработка initData"""
    
    def __init__(self):
        # Получаем токен из переменных окружения
        self.bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
        if not self.bot_token:
            raise ValueError("TELEGRAM_BOT_TOKEN не установлен. Проверьте файл .env")
        
        # Инициализация HTTP клиента
        self.http_client = httpx.AsyncClient(timeout=10.0)
    
    async def validate_init_data(self, init_data: str) -> Dict[str, Any]:
        """
        Валидация initData от Telegram
        
        Args:
            init_data: Строка с данными от Telegram
            
        Returns:
            Словарь с валидированными данными
            
        Raises:
            HTTPException: Если данные невалидны
        """
        try:
            # Парсинг строки запроса
            data = dict(pair.split('=') for pair in init_data.split('&'))
            
            # Валидация хеша (временно упрощенная для разработки)
            if 'hash' not in data:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Отсутствует хеш в initData"
                )
            
            # Возвращаем валидированные данные
            return data
            
        except Exception as e:
            logger.error(f"Ошибка валидации initData: {e}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Невалидные initData"
            )
    
    async def get_user_info(self, telegram_id: int) -> Optional[Dict[str, Any]]:
        """
        Получение информации о пользователе из Telegram
        
        Args:
            telegram_id: ID пользователя в Telegram
            
        Returns:
            Словарь с информацией о пользователе или None
        """
        try:
            # В будущем здесь будет запрос к Telegram API
            # Пока возвращаем тестовые данные
            return {
                "id": telegram_id,
                "first_name": "Test",
                "last_name": "User",
                "username": "testuser"
            }
        except Exception as e:
            logger.error(f"Ошибка получения информации о пользователе: {e}")
            return None
    
    async def send_message(self, chat_id: int, text: str) -> bool:
        """
        Отправка сообщения в Telegram
        
        Args:
            chat_id: ID чата
            text: Текст сообщения
            
        Returns:
            True если сообщение отправлено успешно
        """
        try:
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            payload = {
                "chat_id": chat_id,
                "text": text
            }
            
            response = await self.http_client.post(url, json=payload)
            response.raise_for_status()
            
            return True
        except Exception as e:
            logger.error(f"Ошибка отправки сообщения: {e}")
            return False
    
    async def create_chat_invite_link(self, chat_id: int) -> Optional[str]:
        """
        Создание ссылки-приглашения в чат
        
        Args:
            chat_id: ID чата
            
        Returns:
            Ссылка-приглашение или None
        """
        try:
            url = f"https://api.telegram.org/bot{self.bot_token}/createChatInviteLink"
            payload = {
                "chat_id": chat_id,
                "member_limit": 2  # Только 2 участника
            }
            
            response = await self.http_client.post(url, json=payload)
            response.raise_for_status()
            
            data = response.json()
            return data.get("result", {}).get("invite_link")
            
        except Exception as e:
            logger.error(f"Ошибка создания ссылки-приглашения: {e}")
            return None

# Создаем экземпляр интеграции
telegram_integration = TelegramIntegration()
# AGORA_BLOCK: end:telegram_integration

================================================================================
ФАЙЛ: src\main.py
================================================================================
# AGORA_BLOCK: start:main
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import time
from src.api.auth import router as auth_router
from src.infrastructure.monitoring.monitoringService import monitoring_service
from src.infrastructure.error.errorHandler import ErrorHandler

# Создание приложения FastAPI
app = FastAPI(
    title="Agora.AI API",
    description="Интеллектуальная платформа B2B-сотрудничества",
    version="1.0.0"
)

# Настройка CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # В проде нужно указать конкретные домены
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Подключение роутеров
app.include_router(auth_router, prefix="/api/v1")

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """Middleware для логирования запросов"""
    start_time = time.time()
    
    response = await call_next(request)
    
    # Расчет времени выполнения
    process_time = time.time() - start_time
    
    # Логирование запроса
    monitoring_service.increment_api_requests(
        endpoint=request.url.path,
        method=request.method,
        status=response.status_code
    )
    
    # Отслеживание длительности запроса
    monitoring_service.track_request_duration(process_time)
    
    return response

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Глобальный обработчик исключений"""
    error_info = ErrorHandler.handle_error(exc, "global")
    
    # Логирование ошибки
    monitoring_service.increment_api_errors(
        endpoint=request.url.path,
        status=500
    )
    
    return JSONResponse(
        status_code=500,
        content={"detail": "Внутренняя ошибка сервера"}
    )

@app.get("/")
async def root():
    """Корневой эндпоинт для проверки работы API"""
    return {"message": "Agora.AI API is running"}

@app.get("/health")
async def health_check():
    """Эндпоинт для проверки здоровья сервиса"""
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
# AGORA_BLOCK: end:main

================================================================================
ФАЙЛ: src\test\test_file.py
================================================================================
# AGORA_BLOCK: start:test_block
print('Hello, World!')
# AGORA_BLOCK: end:test_block

================================================================================
ФАЙЛ: src\test\test_utilities.py
================================================================================
# AGORA_BLOCK: start:test_utilities
import sys
import os

# Добавляем корневую директорию проекта в путь для импорта
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.code_utils import CodeBlockManager
from utils.git_integration import GitIntegration

def test_code_utils():
    """Тестирование утилит для работы с блоками кода"""
    
    # Инициализация менеджера блоков кода
    manager = CodeBlockManager()
    
    # Тест 1: Получение содержимого блока
    print("=== Тест 1: Получение содержимого блока ===")
    try:
        content = manager.get_block_content("test_block")
        print(f"Текущее содержимое блока:\n{content}")
    except Exception as e:
        print(f"Ошибка при получении содержимого: {e}")
    
    # Тест 2: Замена кода в блоке
    print("\n=== Тест 2: Замена кода в блоке ===")
    new_code = """def hello_world():
    print("Hello, Updated World!")
    return "updated_success"

def new_function():
    print("This is a new function!")
    return "new_success"  # Исправлено: только одна кавычка в конце"""
    
    try:
        result = manager.replace_block("test_block", new_code)
        print(f"Результат замены: {result}")
    except Exception as e:
        print(f"Ошибка при замене кода: {e}")
    
    # Тест 3: Проверка целостности блока
    print("\n=== Тест 3: Проверка целостности блока ===")
    try:
        is_valid, message = manager.validate_block_integrity("test_block")
        print(f"Целостность блока: {is_valid} - {message}")
    except Exception as e:
        print(f"Ошибка при проверке целостности: {e}")
    
    # Тест 4: Проверка целостности всех блоков
    print("\n=== Тест 4: Проверка целостности всех блоков ===")
    try:
        validation_results = manager.validate_all_blocks()
        for block_id, result in validation_results.items():
            status = "✅" if result['valid'] else "❌"
            print(f"{status} {block_id} ({result['layer']}): {result['message']}")
    except Exception as e:
        print(f"Ошибка при проверке всех блоков: {e}")

if __name__ == "__main__":
    test_code_utils()
# AGORA_BLOCK: end:test_utilities

================================================================================
ФАЙЛ: src\utils\.gitkeep
================================================================================
[БИНАРНЫЙ ФАЙЛ - СОДЕРЖИМОЕ НЕ ПРОЧИТАНО]

================================================================================
ФАЙЛ: src\utils\code_utils.py
================================================================================
# AGORA_BLOCK: start:code_utils
# [Описание: Утилиты для работы с тегированными блоками кода]
# [Зависимости: json, os, re, datetime]
# [Автор: AI_Assistant / Версия: 1.0]
import json
import os
import re
from datetime import datetime
class CodeBlockManager:
    def __init__(self, code_map_path="docs/architecture/code_map.json"):
        self.code_map_path = code_map_path
        self.code_map = self._load_code_map()
    
    def _load_code_map(self):
        """Загрузка кодовой карты из JSON файла"""
        if not os.path.exists(self.code_map_path):
            raise FileNotFoundError(f"Code map file not found: {self.code_map_path}")
        
        with open(self.code_map_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def _save_code_map(self):
        """Сохранение кодовой карты в JSON файл"""
        with open(self.code_map_path, 'w', encoding='utf-8') as f:
            json.dump(self.code_map, f, indent=2, ensure_ascii=False)
    
    def get_block_info(self, block_id):
        """Получение информации о блоке по ID"""
        for layer in self.code_map['layers'].values():
            if block_id in layer['modules']:
                return layer['modules'][block_id]
        raise ValueError(f"Block with ID '{block_id}' not found in code map")
    
    def find_block_in_file(self, file_path, start_tag, end_tag):
        """Поиск границ блока в файле"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except FileNotFoundError:
            raise FileNotFoundError(f"File not found: {file_path}")
        
        start_idx = None
        end_idx = None
        
        for i, line in enumerate(lines):
            if start_tag in line:
                start_idx = i
            if end_tag in line and start_idx is not None:
                end_idx = i
                break
        
        if start_idx is None or end_idx is None:
            raise ValueError(f"Block tags not found in file: {file_path}")
        
        return start_idx, end_idx, lines
    
    def replace_block(self, block_id, new_code, update_metadata=True):
        """Замена кода в указанном блоке"""
        block_info = self.get_block_info(block_id)
        
        start_idx, end_idx, lines = self.find_block_in_file(
            block_info['file'], 
            block_info['start_tag'], 
            block_info['end_tag']
        )
        
        # Формируем новый контент блока с сохранением тегов
        new_lines = (
            lines[:start_idx + 1] +  # Сохраняем start_tag
            [new_code + '\n'] +      # Новый код
            lines[end_idx:]          # Сохраняем end_tag и остальной файл
        )
        
        # Записываем изменения в файл
        with open(block_info['file'], 'w', encoding='utf-8') as f:
            f.writelines(new_lines)
        
        # Обновляем метаданные
        if update_metadata:
            block_info['last_modified'] = datetime.now().isoformat()
            block_info['version'] = self._increment_version(block_info['version'])
            self._save_code_map()
        
        return f"Block '{block_id}' successfully updated in {block_info['file']}"
    
    def get_block_content(self, block_id):
        """Получение текущего содержимого блока"""
        block_info = self.get_block_info(block_id)
        
        start_idx, end_idx, lines = self.find_block_in_file(
            block_info['file'], 
            block_info['start_tag'], 
            block_info['end_tag']
        )
        
        # Извлекаем контент между тегами (без самих тегов)
        block_lines = lines[start_idx + 1 : end_idx]
        return ''.join(block_lines).strip()
    
    def validate_block_integrity(self, block_id):
        """Проверка целостности блока (наличие обоих тегов)"""
        block_info = self.get_block_info(block_id)
        
        try:
            self.find_block_in_file(
                block_info['file'], 
                block_info['start_tag'], 
                block_info['end_tag']
            )
            return True, "Block integrity validated"
        except ValueError as e:
            return False, str(e)
    
    def validate_all_blocks(self):
        """Проверка целостности всех блоков"""
        results = {}
        for layer_name, layer in self.code_map['layers'].items():
            for block_id in layer['modules']:
                is_valid, message = self.validate_block_integrity(block_id)
                results[block_id] = {
                    'valid': is_valid,
                    'message': message,
                    'layer': layer_name
                }
        return results
    
    def _increment_version(self, version):
        """Инкремент версии (семантическое версионирование)"""
        try:
            major, minor, patch = map(int, version.split('.'))
            return f"{major}.{minor}.{patch + 1}"
        except:
            return "1.0.0"
    
    def create_new_block(self, block_id, file_path, start_tag, end_tag, description, layer, dependencies=None):
        """Создание нового блока в кодовой карте"""
        if dependencies is None:
            dependencies = []
        
        # Определяем слой для добавления
        if layer not in self.code_map['layers']:
            raise ValueError(f"Layer '{layer}' not found in code map")
        
        # Проверяем уникальность ID
        for l in self.code_map['layers'].values():
            if block_id in l['modules']:
                raise ValueError(f"Block ID '{block_id}' already exists")
        
        # Создаем запись о новом блоке
        new_block = {
            "id": block_id,
            "file": file_path,
            "start_tag": start_tag,
            "end_tag": end_tag,
            "description": description,
            "dependencies": dependencies,
            "author": "AI_Assistant",
            "version": "1.0.0",
            "last_modified": datetime.now().isoformat()
        }
        
        self.code_map['layers'][layer]['modules'][block_id] = new_block
        self._save_code_map()
        
        return f"New block '{block_id}' created in layer '{layer}'"
# Пример использования
if __name__ == "__main__":
    # Инициализация менеджера
    manager = CodeBlockManager()
    
    # Пример замены кода в блоке
    try:
        result = manager.replace_block(
            block_id="matchmaking_engine",
            new_code="def match_companies(company_a, company_b):\n    # Новая реализация\n    return True"
        )
        print(result)
    except Exception as e:
        print(f"Error: {e}")
    
    # Пример проверки целостности всех блоков
    validation_results = manager.validate_all_blocks()
    for block_id, result in validation_results.items():
        status = "✅" if result['valid'] else "❌"
        print(f"{status} {block_id} ({result['layer']}): {result['message']}")
# AGORA_BLOCK: end:code_utils

================================================================================
ФАЙЛ: src\utils\git_integration.py
================================================================================
# AGORA_BLOCK: start:git_integration
# [Описание: Интеграция с Git для автоматического коммита изменений]
# [Зависимости: subprocess]
# [Автор: AI_Assistant / Версия: 1.0]
import subprocess
class GitIntegration:
    @staticmethod
    def commit_changes(block_id, message=None):
        """Автоматический коммит изменений с указанием ID блока"""
        if message is None:
            message = f"AI update: Modified block '{block_id}'"
        
        try:
            # Добавляем измененные файлы
            subprocess.run(["git", "add", "."], check=True)
            
            # Создаем коммит
            subprocess.run(
                ["git", "commit", "-m", message],
                check=True,
                capture_output=True,
                text=True
            )
            
            return f"Changes committed: {message}"
        except subprocess.CalledProcessError as e:
            return f"Git commit failed: {e.stderr}"
# AGORA_BLOCK: end:git_integration

================================================================================
ФАЙЛ: src\utils\interactive_update.py
================================================================================
# AGORA_BLOCK: start:interactive_update
import sys
import os

# Добавляем корневую директорию проекта в sys.path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))

from src.utils.code_utils import CodeBlockManager
from src.utils.git_integration import GitIntegration

def interactive_update():
    manager = CodeBlockManager()
    
    print("Доступные блоки:")
    for layer_name, layer in manager.code_map['layers'].items():
        for block_id in layer['modules']:
            print(f"- {block_id} ({layer_name})")
    
    block_id = input("Введите ID блока для обновления: ")
    
    print("Введите новый код (завершите пустой строкой):")
    lines = []
    while True:
        line = input()
        if line == "":
            break
        lines.append(line)
    
    new_code = "\n".join(lines)
    
    result = manager.replace_block(block_id, new_code)
    print(result)
    
    commit = input("Сделать коммит? (y/n): ")
    if commit.lower() == 'y':
        GitIntegration.commit_changes(block_id)
        print("Changes committed to Git")

if __name__ == "__main__":
    interactive_update()
# AGORA_BLOCK: end:interactive_update

================================================================================
ФАЙЛ: src\utils\project_structure_exporter.py
================================================================================
# AGORA_BLOCK: start:project_structure_exporter
import os
import datetime
from typing import List, Set

class ProjectStructureExporter:
    def __init__(self, root_path: str = ".", output_file: str = "project_structure.txt"):
        self.root_path = os.path.abspath(root_path)
        self.output_file = output_file
        self.text_extensions = {'.py', '.txt', '.json', '.md', '.yml', '.yaml', '.env', '.ini', '.cfg', '.toml', '.xml', '.html', '.css', '.js', '.sql', '.sh', '.bat', '.ps1', '.gitignore', '.dockerignore'}
        self.skip_dirs = {'.git', '__pycache__', '.pytest_cache', 'node_modules', '.vscode', '.idea', 'venv', 'env', 'dist', 'build'}
        
    def should_skip_directory(self, dir_name: str) -> bool:
        """Проверить, нужно ли пропустить директорию"""
        return dir_name in self.skip_dirs or dir_name.startswith('.')
    
    def should_read_file(self, file_path: str) -> bool:
        """Проверить, нужно ли читать содержимое файла"""
        _, ext = os.path.splitext(file_path)
        return ext.lower() in self.text_extensions
    
    def get_directory_structure(self, path: str, prefix: str = "") -> List[str]:
        """Рекурсивно получить структуру директорий"""
        structure = []
        try:
            items = sorted(os.listdir(path))
        except PermissionError:
            return structure
        
        dirs = []
        files = []
        for item in items:
            full_path = os.path.join(path, item)
            if os.path.isdir(full_path):
                if not self.should_skip_directory(item):
                    dirs.append(item)
            else:
                files.append(item)
        
        # Сначала директории
        for i, dir_name in enumerate(dirs):
            is_last_dir = i == len(dirs) - 1 and len(files) == 0
            current_prefix = "└── " if is_last_dir else "├── "
            structure.append(prefix + current_prefix + dir_name + "/")
            
            next_prefix = prefix + ("    " if is_last_dir else "│   ")
            structure.extend(self.get_directory_structure(os.path.join(path, dir_name), next_prefix))
        
        # Затем файлы
        for i, file_name in enumerate(files):
            is_last_file = i == len(files) - 1
            current_prefix = "└── " if is_last_file else "├── "
            structure.append(prefix + current_prefix + file_name)
        
        return structure
    
    def read_file_content(self, file_path: str) -> str:
        """Прочитать содержимое файла с обработкой ошибок"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                return f"[Ошибка чтения файла: {str(e)}]"
        except Exception as e:
            return f"[Ошибка чтения файла: {str(e)}]"
    
    def export_project(self):
        """Основной метод экспорта проекта"""
        print(f"Начинаю экспорт структуры проекта из: {self.root_path}")
        print(f"Результат будет сохранен в: {self.output_file}")
        
        # Получаем структуру директорий
        structure_lines = self.get_directory_structure(self.root_path)
        
        with open(self.output_file, 'w', encoding='utf-8') as f:
            # Заголовок
            f.write("=" * 80 + "\n")
            f.write("СТРУКТУРА ПРОЕКТА\n")
            f.write("=" * 80 + "\n")
            f.write(f"Дата создания: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Корневая директория: {self.root_path}\n")
            f.write("=" * 80 + "\n\n")
            
            # Иерархия папок и файлов
            f.write("ИЕРАРХИЯ ПАПОК И ФАЙЛОВ:\n")
            f.write("-" * 40 + "\n")
            for line in structure_lines:
                f.write(line + "\n")
            f.write("\n" + "=" * 80 + "\n\n")
            
            # Содержимое файлов
            f.write("СОДЕРЖИМОЕ ФАЙЛОВ:\n")
            f.write("-" * 40 + "\n")
            
            # Собираем все файлы для обработки
            all_files = []
            for root, dirs, files in os.walk(self.root_path):
                # Пропускаем нежелательные директории
                dirs[:] = [d for d in dirs if not self.should_skip_directory(d)]
                
                for file in files:
                    file_path = os.path.join(root, file)
                    relative_path = os.path.relpath(file_path, self.root_path)
                    all_files.append((relative_path, file_path))
            
            # Сортируем файлы по пути
            all_files.sort(key=lambda x: x[0])
            
            # Записываем содержимое каждого файла
            for relative_path, file_path in all_files:
                if self.should_read_file(file_path):
                    f.write(f"\n{'='*80}\n")
                    f.write(f"ФАЙЛ: {relative_path}\n")
                    f.write(f"{'='*80}\n")
                    content = self.read_file_content(file_path)
                    f.write(content)
                    if not content.endswith('\n'):
                        f.write('\n')
                else:
                    f.write(f"\n{'='*80}\n")
                    f.write(f"ФАЙЛ: {relative_path}\n")
                    f.write(f"{'='*80}\n")
                    f.write(f"[БИНАРНЫЙ ФАЙЛ - СОДЕРЖИМОЕ НЕ ПРОЧИТАНО]\n")
        
        print(f"Экспорт завершен! Результат сохранен в файл: {self.output_file}")
        print(f"Размер файла: {os.path.getsize(self.output_file)} байт")

def main():
    """Основная функция для запуска утилиты"""
    print("Утилита экспорта структуры проекта")
    print("=" * 50)
    
    # Создаем экспортер
    exporter = ProjectStructureExporter()
    
    # Запускаем экспорт
    exporter.export_project()

if __name__ == "__main__":
    main()
# AGORA_BLOCK: end:project_structure_exporter

================================================================================
ФАЙЛ: src\utils\update_code.py
================================================================================
# AGORA_BLOCK: start:update_code
import sys
import os

# Добавляем корневую директорию проекта в sys.path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))

from src.utils.code_utils import CodeBlockManager
from src.utils.git_integration import GitIntegration

def update_block(block_id, new_code):
    manager = CodeBlockManager()
    result = manager.replace_block(block_id, new_code)
    print(result)
    
    # Автоматический коммит
    GitIntegration.commit_changes(block_id)
    print("Changes committed to Git")

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 3:
        print("Usage: python src/utils/update_code.py <block_id> <new_code>")
        sys.exit(1)
    
    block_id = sys.argv[1]
    new_code = sys.argv[2]
    
    update_block(block_id, new_code)
# AGORA_BLOCK: end:update_code

================================================================================
ФАЙЛ: test_env.py
================================================================================
import os
from dotenv import load_dotenv

# Загружаем переменные окружения из .env
load_dotenv()

print("TELEGRAM_BOT_TOKEN:", os.getenv("TELEGRAM_BOT_TOKEN"))
print("JWT_SECRET:", os.getenv("JWT_SECRET"))
